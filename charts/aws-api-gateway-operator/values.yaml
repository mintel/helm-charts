# Default values for aws-api-gateway-operator.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# -- Global variables for us in all charts and sub charts
global:
  # -- Name of the application
  name: "aws-load-balancer-controller"
  # -- Team which "owns" the application
  owner: "SRE"
  # -- Additional labels to apply to all resources
  additionalLabels: {}
  # -- Environment (local, dev, qa, prod)
  clusterEnv: "local"

replicaCount: 2

image:
  repository: registry.gitlab.com/mintel/satoshi/tools/aws-api-gateway-operator
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: v1.0.0

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""
  # Automount API credentials for a Service Account.
  automountServiceAccountToken: true
  # List of image pull secrets to add to the Service Account.
  imagePullSecrets:
    # - name: docker

rbac:
  # Specifies whether rbac resources should be created
  create: true

podAnnotations: {}

podSecurityContext:
  fsGroup: 65534

# Time period for the operator pod to do a graceful shutdown
terminationGracePeriodSeconds: 10

resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

# priorityClassName specifies the PriorityClass to indicate the importance of operator pods
# ref: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass
# note: infra is Mintel specific, if we make this open-source in the future change this
# default to system-cluster-critical
priorityClassName: infra

nodeSelector: {}

tolerations: []

# affinity can be either a string or map.
#
# if affinity is a string, and if that string is "default", set an antiAffinity policy on
# the podSpec to prevent colocation on the same node.
#
# if affinity is a map, set the affinity attribute on the podSpec with this exact value (do NOT
# use the default, as described above).
# affinity: {}
affinity: default

# topologySpreadConstraints is a stable feature of k8s v1.19 which provides the ability to
# control how Pods are spread across your cluster among failure-domains such as regions, zones,
# nodes, and other user-defined topology domains.
#
# more details here: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
topologySpreadConstraints: {}

updateStrategy: {}
  # type: RollingUpdate
  # rollingUpdate:
  #   maxSurge: 1
  #   maxUnavailable: 1

# serviceAnnotations contains annotations to be added to the provisioned webhook service resource
serviceAnnotations: {}

# deploymentAnnotations contains annotations for the operator deployment
deploymentAnnotations: {}

podLabels: {}

# additionalLabels -- Labels to add to each object of the chart.
additionalLabels: {}

# The address the probe endpoint binds to (default ":8081")
probeAddr: ""

# Enable leader election for controller manager, ensuring there is only one active controller manager. (default "false")
enableLeaderElection:

# Enable Zap Development mode (adds WARN logging) (default "false").
zapDevelopmentConfig:

# Liveness probe configuration for the operator
livenessProbe:
  failureThreshold: 2
  httpGet:
    path: /healthz
    port: 61779
    scheme: HTTP
  initialDelaySeconds: 30
  timeoutSeconds: 10

# Environment variables to set for aws-api-gateway-operator pod.
# We strongly discourage programming access credentials in the operator environment. You should setup IRSA or
# comparable solutions like kube2iam, kiam etc instead.
env:
  # ENV_1: ""
  # ENV_2: ""

# defaultTags are the tags to apply to all AWS resources managed by this operator
defaultTags: {}
  # default_tag1: value1
  # default_tag2: value2

# podDisruptionBudget specifies the disruption budget for the operator pods.
# Disruption budget will be configured only when the replicaCount is greater than 1
podDisruptionBudget: {}
#  maxUnavailable: 1

# -- Prometheus Exporter / Metrics
metrics:
  # -- Enable Prometheus to access aplpication metrics endpoints
  enabled: true
  # -- Interval at which metrics should be scraped
  # ref: https://github.com/coreos/prometheus-operator/blob/master/Documentation/api.md#endpoint
  #  interval: 30s
  # -- URL path to the metrics endpoint
  #  path: /metrics
  # -- Name of the port to use for metrics endpoint
  #  port: http
  # -- Timeout after which the scrape is ended
  # ref: https://github.com/coreos/prometheus-operator/blob/master/Documentation/api.md#endpoint
  #  timeout: 10s
  # -- Scheme (HTTP ot HTTPS)
  #  scheme: HTTP
  basicAuth:
    enabled: false
    secretName: ""
    usernameKey: ""
    passwordKey: ""
